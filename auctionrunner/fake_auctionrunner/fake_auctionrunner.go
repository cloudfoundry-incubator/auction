// This file was generated by counterfeiter
package fake_auctionrunner

import (
	. "github.com/cloudfoundry-incubator/auction/auctiontypes"
	"sync"
)

type FakeAuctionRunner struct {
	RunLRPStartAuctionStub        func(auctionRequest StartAuctionRequest) (StartAuctionResult, error)
	runLRPStartAuctionMutex       sync.RWMutex
	runLRPStartAuctionArgsForCall []struct {
		arg1 StartAuctionRequest
	}
	runLRPStartAuctionReturns struct {
		result1 StartAuctionResult
		result2 error
	}
	RunLRPStopAuctionStub        func(auctionRequest StopAuctionRequest) (StopAuctionResult, error)
	runLRPStopAuctionMutex       sync.RWMutex
	runLRPStopAuctionArgsForCall []struct {
		arg1 StopAuctionRequest
	}
	runLRPStopAuctionReturns struct {
		result1 StopAuctionResult
		result2 error
	}
}

func (fake *FakeAuctionRunner) RunLRPStartAuction(arg1 StartAuctionRequest) (StartAuctionResult, error) {
	fake.runLRPStartAuctionMutex.Lock()
	defer fake.runLRPStartAuctionMutex.Unlock()
	fake.runLRPStartAuctionArgsForCall = append(fake.runLRPStartAuctionArgsForCall, struct {
		arg1 StartAuctionRequest
	}{arg1})
	if fake.RunLRPStartAuctionStub != nil {
		return fake.RunLRPStartAuctionStub(arg1)
	} else {
		return fake.runLRPStartAuctionReturns.result1, fake.runLRPStartAuctionReturns.result2
	}
}

func (fake *FakeAuctionRunner) RunLRPStartAuctionCallCount() int {
	fake.runLRPStartAuctionMutex.RLock()
	defer fake.runLRPStartAuctionMutex.RUnlock()
	return len(fake.runLRPStartAuctionArgsForCall)
}

func (fake *FakeAuctionRunner) RunLRPStartAuctionArgsForCall(i int) StartAuctionRequest {
	fake.runLRPStartAuctionMutex.RLock()
	defer fake.runLRPStartAuctionMutex.RUnlock()
	return fake.runLRPStartAuctionArgsForCall[i].arg1
}

func (fake *FakeAuctionRunner) RunLRPStartAuctionReturns(result1 StartAuctionResult, result2 error) {
	fake.runLRPStartAuctionReturns = struct {
		result1 StartAuctionResult
		result2 error
	}{result1, result2}
}

func (fake *FakeAuctionRunner) RunLRPStopAuction(arg1 StopAuctionRequest) (StopAuctionResult, error) {
	fake.runLRPStopAuctionMutex.Lock()
	defer fake.runLRPStopAuctionMutex.Unlock()
	fake.runLRPStopAuctionArgsForCall = append(fake.runLRPStopAuctionArgsForCall, struct {
		arg1 StopAuctionRequest
	}{arg1})
	if fake.RunLRPStopAuctionStub != nil {
		return fake.RunLRPStopAuctionStub(arg1)
	} else {
		return fake.runLRPStopAuctionReturns.result1, fake.runLRPStopAuctionReturns.result2
	}
}

func (fake *FakeAuctionRunner) RunLRPStopAuctionCallCount() int {
	fake.runLRPStopAuctionMutex.RLock()
	defer fake.runLRPStopAuctionMutex.RUnlock()
	return len(fake.runLRPStopAuctionArgsForCall)
}

func (fake *FakeAuctionRunner) RunLRPStopAuctionArgsForCall(i int) StopAuctionRequest {
	fake.runLRPStopAuctionMutex.RLock()
	defer fake.runLRPStopAuctionMutex.RUnlock()
	return fake.runLRPStopAuctionArgsForCall[i].arg1
}

func (fake *FakeAuctionRunner) RunLRPStopAuctionReturns(result1 StopAuctionResult, result2 error) {
	fake.runLRPStopAuctionReturns = struct {
		result1 StopAuctionResult
		result2 error
	}{result1, result2}
}

var _ AuctionRunner = new(FakeAuctionRunner)
